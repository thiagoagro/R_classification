---
title: "ML Classification"
author: "Thiago Orlando Costa Barboza"
date: "2025-11-03"
output:
  pdf_document: default
  html_document: default
---


# 1Â° - Install packages and clone github

```{r}

#1Â° install the packages:
install.packages(c('terra','mapview','sf','stars','caret','mapedit','devtools',"dplyr",
                   "fields","leafem","leafsync","lwgeom","BiocManager","git2r","exactextractr","rgdal", "xgboost",
                   "nnet", "caret", "e1071","pliman", "Rtools","randomForest", "kernelab"))

#2Â° install the dependency for FieldImageR:
BiocManager::install("EBImage")

#3Â° install FIELDimageR and FieldImageR.extra:
devtools::install_github("OpenDroneMap/FIELDimageR")
devtools::install_github("filipematias23/FIELDimageR.Extra")
```

# 2Â° - Call libraries

```{r}

library(webshot)
library(webshot2)
library(tinytex)
library(rmarkdown)
library(raster)
library(FIELDimageR)
library(FIELDimageR.Extra)
library(terra)
library(mapview)
library(sf)
library(stars)
library(nlme)
library(imager)
library(leafsync)
library(pliman)
library(gdalUtilities)
library(ggplot2)
library(gridExtra)
library(RStoolbox)
library(patchwork)
library(tidyr)
library(caret)
library(e1071)    
library(xgboost)    
library(nnet)
library(dplyr)
library(viridis)
library(randomForest)
library(kernlab)
```

# 3Â° - Find the location to clip the image

```{r, open the image in webshot}

#open the save orthomosaic again
bandset <- rast("F:/orto/ORTO.tif")
bandset

#Call the shape and find the locations to clip
shp <- read_sf("F:/orto/poligono.shp")
shp <- st_transform(shp, crs = 4326)
shp

#Clip the field 
bandset_1 <- mask(crop(bandset, shp), shp)

#this function you can see your raster image
fieldView(bandset_1, shp)

```

# 4Â° Creating the sample for classification

```{r}
#create the soil and plant samples
# Digitize soil object by drawing polygons at least 5-6 large polygon uniformly distributed
#generate random 400 points for soil class
orto <- bandset_1
soil<-fieldView(mosaic = orto, editor = TRUE)
soil<-st_as_sf(st_sample(soil, 400))
soil$class<-'soil'

# Digitize plants object by drawing polygons 
#The number of polygon will depends upon the number of training points to be generated
#generate random 400 points for plants class
plants<-fieldView(mosaic = orto, editor = TRUE)
plants<-st_as_sf(st_sample(plants, 400))
plants$class<-'plants'

#You also can add more class like forest, water, etc.
pd<-fieldView(mosaic = orto, editor = TRUE)
pd<-st_as_sf(st_sample(pd, 400))
pd$class<-'pd'
#joining all class in one file
training_sam<-rbind(soil,plants,pd)

#Checking the points
fieldView(bandset_1, plants)
```

# 5Â° - Running ML models

```{r, warning = FALSE}
run_classification_models <- function(
  raster_data,
  training_data,
  models = c("rf", "svmRadial", "xgbTree"),
  response_col = "class",
  tune_length = 3,
  kfold = 5,
  train_partition = 0.7,
  min_dist = 0,
  plot_results = TRUE
) {
  # Garantir nomes Ãºnicos
  names(raster_data) <- make.unique(names(raster_data))

  # Converter para Spatial se necessÃ¡rio
  if (!inherits(training_data, "Spatial")) {
    training_data <- as(training_data, "Spatial")
  }

  # Armazenar resultados
  results <- list()

  for (model in models) {
    message(paste("Treinando modelo:", model))
    
    model_result <- superClass(
      raster_data,
      trainData = training_data,
      responseCol = response_col,
      model = model,
      tuneLength = tune_length,
      kfold = kfold,
      trainPartition = train_partition,
      minDist = min_dist
    )
    
    # Nome do objeto no padrÃ£o result_MODEL
    result_name <- paste0("result_", toupper(gsub("^(.)", "\\U\\1", model, perl = TRUE)))
    
    if (plot_results) {
      plot(model_result$map, main = paste("Mapa classificado -", model))
      fieldView(raster_data, model_result$map)
      print(model_result$validation$performance)
    }
    
    results[[result_name]] <- model_result
  }

  return(results)
}

#After define the function run this line to use the function

band_result <- run_classification_models(raster_data = bandset_1, 
                                         training_data = training_sam,
                                         models = c("rf", "svmRadial", "xgbTree"),
                                         kfold = 5,
                                         train_partition = 0.7,
                                         plot_results = TRUE)

```
# 6Â° - Save the map

```{r}
# Helper function to convert raster to dataframe
raster_to_df <- function(raster_obj, value_name = "value") {
  df <- as.data.frame(raster_obj, xy = TRUE, na.rm = FALSE)
  if (ncol(df) == 3) {
    names(df)[3] <- value_name
  }
  return(df)
}

# Helper function to plot the raster dataframe
plot_raster_df <- function(df, value_col, title) {
  ggplot(df, aes(x = x, y = y, fill = as.factor(.data[[value_col]]))) +
    geom_raster() +
    scale_fill_viridis_d() +
    coord_equal() +
    labs(title = title, fill = "Class") +
    theme_bw()
}

# Main function - VERSÃƒO MELHORADA
plot_and_save_results <- function(result_list, 
                                   save_dir,
                                   combined_nrow = NULL,
                                   combined_ncol = NULL,
                                   combined_width = NULL,
                                   combined_height = NULL,
                                   individual_width = 8,
                                   individual_height = 6,
                                   dpi = 600) {
  
  # Verificar se o diretÃ³rio existe
  if (!dir.exists(save_dir)) {
    stop("Directory does not exist: ", save_dir, 
         "\nPlease create it or check the path.")
  }
  
  # Mapear nomes dos modelos para seus resultados
  model_mapping <- list(
    RF = "result_RF",
    SVM = "result_SVMRADIAL",
    XGB = "result_XGBTREE"
  )
  
  # Verificar quais modelos estÃ£o presentes
  available_models <- c()
  results_named <- list()
  
  for (model_name in names(model_mapping)) {
    result_key <- model_mapping[[model_name]]
    
    # Checar se o modelo existe na lista de resultados
    if (!is.null(result_list[[result_key]])) {
      available_models <- c(available_models, model_name)
      results_named[[model_name]] <- result_list[[result_key]]
      message("âœ“ Modelo ", model_name, " encontrado")
    } else {
      message("âœ— Modelo ", model_name, " nÃ£o encontrado - serÃ¡ ignorado")
    }
  }
  
  # Verificar se pelo menos um modelo foi encontrado
  if (length(available_models) == 0) {
    stop("Nenhum modelo vÃ¡lido encontrado (RF, SVM, XGB). ",
         "Verifique os nomes dos resultados na lista.")
  }
  
  message("\n", length(available_models), " modelo(s) disponÃ­vel(is): ", 
          paste(available_models, collapse = ", "))
  
  # Criar plots individuais
  plots <- list()
  plot_dfs <- list()
  
  for (model_name in available_models) {
    result <- results_named[[model_name]]
    df <- raster_to_df(result$map, value_name = model_name)
    plot <- plot_raster_df(df, model_name, paste(model_name, "Classification"))
    
    # Salvar plot individual
    plot_path <- file.path(save_dir, paste0("plot_", model_name, ".png"))
    ggsave(plot_path, plot, 
           height = individual_height, 
           width = individual_width, 
           dpi = dpi)
    message("  â†’ Plot individual salvo: ", basename(plot_path))
    
    plots[[model_name]] <- plot
    plot_dfs[[model_name]] <- df
  }
  
  # Configurar layout automÃ¡tico baseado no nÃºmero de modelos
  n_models <- length(available_models)
  
  # Definir nrow e ncol automaticamente se nÃ£o fornecidos
  if (is.null(combined_nrow) && is.null(combined_ncol)) {
    if (n_models == 1) {
      combined_nrow <- 1
      combined_ncol <- 1
    } else if (n_models == 2) {
      combined_nrow <- 1
      combined_ncol <- 2
    } else if (n_models == 3) {
      combined_nrow <- 2
      combined_ncol <- 2
    } else {
      # Para mais de 3 modelos (caso futuro)
      combined_ncol <- ceiling(sqrt(n_models))
      combined_nrow <- ceiling(n_models / combined_ncol)
    }
  } else if (is.null(combined_nrow)) {
    combined_nrow <- ceiling(n_models / combined_ncol)
  } else if (is.null(combined_ncol)) {
    combined_ncol <- ceiling(n_models / combined_nrow)
  }
  
  # Definir dimensÃµes automÃ¡ticas se nÃ£o fornecidas
  if (is.null(combined_width)) {
    combined_width <- individual_width * combined_ncol
  }
  if (is.null(combined_height)) {
    combined_height <- individual_height * combined_nrow
  }
  
  # Criar plot combinado usando patchwork
  if (n_models == 1) {
    combined_plot <- plots[[1]]
  } else {
    # Combinar plots dinamicamente
    combined_plot <- wrap_plots(plots, nrow = combined_nrow, ncol = combined_ncol)
  }
  
  # Salvar plot combinado
  combined_path <- file.path(save_dir, "combined_plot.png")
  ggsave(combined_path, combined_plot, 
         height = combined_height, 
         width = combined_width, 
         dpi = dpi)
  
  message("\nâœ“ Model save in ", basename(combined_path))
  message("  Dimensions: ", combined_width, "x", combined_height, "inch")
  message("  Layout: ", combined_nrow, " line x ", combined_ncol, " col(s)")
  message("\nâœ“ All plots save in: ", save_dir)
  
  # Retornar informaÃ§Ãµes Ãºteis
  return(list(
    combined_plot = combined_plot,
    individual_plots = plots,
    available_models = available_models,
    save_directory = save_dir
  ))
}

#Running the function
combined_result <- plot_and_save_results(
   result_list = band_result,
   save_dir = "F:/orto/results",
   combined_nrow = 3,
   combined_ncol = 1,
   combined_width = 8,
   combined_height = 18)

```

# 7Â° - Metrics and Confusion matrix

```{r}
# ============================================================================
# HELPER FUNCTIONS - MÃ‰TRICAS GERAIS
# ============================================================================

# Helper function to extract and format overall metrics
extract_metrics <- function(result, model_name) {
  if (is.null(result)) return(NULL)
  
  metrics <- NULL
  
  # Tentar extrair mÃ©tricas de diferentes estruturas
  if (!is.null(result$metrics)) {
    metrics <- result$metrics
  } else if (!is.null(result$validation$performance)) {
    # Estrutura com validation
    perf <- result$validation$performance
    metrics <- list()
    
    # Extrair mÃ©tricas gerais (overall)
    if (!is.null(perf$overall)) metrics <- c(metrics, as.list(perf$overall))
    if (!is.null(perf$accuracy)) metrics$Accuracy <- perf$accuracy
    if (!is.null(perf$kappa)) metrics$Kappa <- perf$kappa
    
  } else if (!is.null(result$confusion_matrix)) {
    # Calcular mÃ©tricas da matriz de confusÃ£o
    cm <- result$confusion_matrix
    metrics <- list(
      Accuracy = sum(diag(cm)) / sum(cm),
      Kappa = result$kappa
    )
  }
  
  if (is.null(metrics) || length(metrics) == 0) {
    warning("MÃ©tricas nÃ£o encontradas para ", model_name)
    return(NULL)
  }
  
  # Converter para dataframe
  metrics_df <- data.frame(
    Metric = names(metrics),
    Value = as.numeric(metrics),
    Model = model_name,
    stringsAsFactors = FALSE
  )
  
  # Filtrar apenas valores numÃ©ricos vÃ¡lidos
  metrics_df <- metrics_df[!is.na(metrics_df$Value), ]
  
  return(metrics_df)
}

# ============================================================================
# HELPER FUNCTIONS - MÃ‰TRICAS POR CLASSE
# ============================================================================

# Helper function to extract per-class metrics
extract_byclass_metrics <- function(result, model_name) {
  if (is.null(result)) return(NULL)
  
  byClass <- NULL
  
  # Tentar extrair byClass de diferentes estruturas
  if (!is.null(result$validation$performance$byClass)) {
    byClass <- result$validation$performance$byClass
  } else if (!is.null(result$byClass)) {
    byClass <- result$byClass
  } else if (!is.null(result$confusionMatrix$byClass)) {
    byClass <- result$confusionMatrix$byClass
  }
  
  if (is.null(byClass)) {
    warning("MÃ©tricas por classe (byClass) nÃ£o encontradas para ", model_name)
    return(NULL)
  }
  
  # Converter para dataframe
  # byClass pode ser uma matriz ou dataframe
  if (is.matrix(byClass)) {
    byClass_df <- as.data.frame(byClass)
  } else if (is.data.frame(byClass)) {
    byClass_df <- byClass
  } else {
    warning("Formato de byClass nÃ£o reconhecido para ", model_name)
    return(NULL)
  }
  
  # Adicionar coluna de classe (do nome das linhas)
  byClass_df$Class <- rownames(byClass_df)
  
  # Limpar nomes das classes (remover "Class: " se presente)
  byClass_df$Class <- gsub("Class: ", "", byClass_df$Class)
  
  # Adicionar coluna do modelo
  byClass_df$Model <- model_name
  
  # Resetar rownames
  rownames(byClass_df) <- NULL
  
  # Reorganizar colunas
  cols <- c("Model", "Class", setdiff(names(byClass_df), c("Model", "Class")))
  byClass_df <- byClass_df[, cols]
  
  return(byClass_df)
}

# Function to create per-class metric comparison plot
create_byclass_metric_plot <- function(byclass_df, metric_name, title = NULL) {
  if (is.null(title)) {
    title <- paste(metric_name, "by Class and Model")
  }
  
  # Verificar se a mÃ©trica existe
  if (!metric_name %in% names(byclass_df)) {
    warning("MÃ©trica '", metric_name, "' nÃ£o encontrada em byClass")
    return(NULL)
  }
  
  # Preparar dados
  plot_data <- byclass_df[, c("Model", "Class", metric_name)]
  names(plot_data)[3] <- "Value"
  
  # Remover NAs
  plot_data <- plot_data[!is.na(plot_data$Value), ]
  
  if (nrow(plot_data) == 0) {
    warning("Sem dados vÃ¡lidos para plotar ", metric_name)
    return(NULL)
  }
  
  # Criar o grÃ¡fico
  ggplot(plot_data, aes(x = Model, y = Value, fill = Class)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.8), 
             width = 0.7, color = "black", linewidth = 0.3) +
    geom_text(aes(label = sprintf("%.3f", Value)), 
              position = position_dodge(width = 0.8),
              vjust = -0.5, size = 3.5, fontface = "bold") +
    scale_fill_viridis_d(option = "turbo") +
    ylim(0, max(plot_data$Value, na.rm = TRUE) * 1.15) +
    labs(
      title = title,
      x = "Model",
      y = metric_name,
      fill = "Class"
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.title = element_text(size = 20),
      axis.text = element_text(size = 20),
      legend.position = "right",
      legend.title = element_text(face = "bold"),
      legend.text = element_text(size = 16)
    )
}

# ============================================================================
# HELPER FUNCTIONS - CONFUSION MATRIX
# ============================================================================

# Helper function to extract confusion matrix
extract_confusion_matrix <- function(result, model_name) {
  if (is.null(result)) return(NULL)
  
  conf_mat <- NULL
  
  # Tentar diferentes estruturas
  if (!is.null(result$validation$performance$table)) {
    conf_mat <- result$validation$performance$table
  } else if (!is.null(result$confusion_matrix)) {
    conf_mat <- result$confusion_matrix
  } else if (!is.null(result$confusionMatrix)) {
    conf_mat <- result$confusionMatrix$table
  }
  
  if (is.null(conf_mat)) {
    warning("Matriz de confusÃ£o nÃ£o encontrada para ", model_name)
    return(NULL)
  }
  
  return(conf_mat)
}

# Function to plot confusion matrix
plot_confusion_matrix <- function(conf_mat, model_name = "Model") {
  conf_df <- as.data.frame(as.table(conf_mat))
  colnames(conf_df) <- c("Prediction", "Reference", "Count")
  
  ggplot(conf_df, aes(x = Reference, y = Prediction, fill = Count)) +
    geom_tile(color = "white", size = 1) +
    geom_label(aes(label = Count),
               fill = "white",
               color = "black",
               size = 5,
               fontface = "bold",
               label.size = 0.3,
               label.r = unit(0.15, "lines")) +
    scale_fill_viridis_c(option = "D", direction = -1) +
    labs(
      title = paste("Confusion Matrix -", model_name),
      x = "True Class",
      y = "Predicted Class",
      fill = "Count"
    ) +
    coord_equal() +
    theme_bw(base_size = 18) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "right",
      axis.text.x = element_text(size = 20),
      axis.text.y = element_text(size = 20)
    )
}

# ============================================================================
# HELPER FUNCTIONS - OVERALL METRICS PLOTS
# ============================================================================

# Function to create overall metric comparison plot
create_metric_plot <- function(metrics_df, metric_name, title = NULL) {
  if (is.null(title)) {
    title <- paste(metric_name, "Comparison")
  }
  
  metric_data <- metrics_df[metrics_df$Metric == metric_name, ]
  
  if (nrow(metric_data) == 0) {
    warning("MÃ©trica ", metric_name, " nÃ£o encontrada")
    return(NULL)
  }
  
  ggplot(metric_data, aes(x = Model, y = Value, fill = Model)) +
    geom_bar(stat = "identity", width = 0.7, color = "black") +
    geom_text(aes(label = sprintf("%.3f", Value)), 
              vjust = -0.5, size = 4, fontface = "bold") +
    scale_fill_viridis_d() +
    ylim(0, max(metric_data$Value) * 1.15) +
    labs(
      title = title,
      x = "Model",
      y = metric_name
    ) +
    theme_bw() +
    theme(
      legend.position = "none",
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.title = element_text(size = 20),
      axis.text = element_text(size = 20)
    )
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

plot_and_save_metrics <- function(result_list,
                                   save_dir,
                                   # MÃ©tricas gerais (overall)
                                   overall_metrics_to_plot = c("Accuracy", "Kappa"),
                                   # MÃ©tricas por classe
                                   byclass_metrics_to_plot = c("Sensitivity", "Specificity", 
                                                               "Precision", "Recall", "F1"),
                                   include_confusion_matrix = TRUE,
                                   # ParÃ¢metros para grÃ¡ficos de mÃ©tricas gerais
                                   overall_metrics_nrow = NULL,
                                   overall_metrics_ncol = NULL,
                                   overall_metrics_width = NULL,
                                   overall_metrics_height = NULL,
                                   overall_metric_individual_width = 6,
                                   overall_metric_individual_height = 5,
                                   # ParÃ¢metros para grÃ¡ficos de mÃ©tricas por classe
                                   byclass_metrics_nrow = NULL,
                                   byclass_metrics_ncol = NULL,
                                   byclass_metrics_width = NULL,
                                   byclass_metrics_height = NULL,
                                   byclass_metric_individual_width = 8,
                                   byclass_metric_individual_height = 6,
                                   # ParÃ¢metros para matrizes de confusÃ£o
                                   cm_nrow = NULL,
                                   cm_ncol = NULL,
                                   cm_width = NULL,
                                   cm_height = NULL,
                                   cm_individual_size = 6,
                                   # Geral
                                   dpi = 600) {
  
  # Verificar pacotes necessÃ¡rios
  required_packages <- c("ggplot2", "patchwork", "viridis")
  missing_packages <- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]
  
  if (length(missing_packages) > 0) {
    stop("Pacotes necessÃ¡rios nÃ£o instalados: ", paste(missing_packages, collapse = ", "),
         "\nInstale com: install.packages(c('", paste(missing_packages, collapse = "', '"), "'))")
  }
  
  library(ggplot2)
  library(patchwork)
  library(viridis)
  
  # Verificar se o diretÃ³rio existe
  if (!dir.exists(save_dir)) {
    stop("Directory does not exist: ", save_dir, 
         "\nPlease create it or check the path.")
  }
  
  # Mapear nomes dos modelos
  model_mapping <- list(
    RF = "result_RF",
    SVM = "result_SVMRADIAL",
    XGB = "result_XGBTREE"
  )
  
  # Verificar modelos disponÃ­veis
  available_models <- c()
  all_overall_metrics <- list()
  all_byclass_metrics <- list()
  all_conf_matrices <- list()
  
  message("=== EXTRAINDO DADOS DOS MODELOS ===\n")
  
  for (model_name in names(model_mapping)) {
    result_key <- model_mapping[[model_name]]
    
    if (!is.null(result_list[[result_key]])) {
      available_models <- c(available_models, model_name)
      message("Modelo: ", model_name)
      
      # Extrair mÃ©tricas gerais
      overall_metrics <- extract_metrics(result_list[[result_key]], model_name)
      if (!is.null(overall_metrics)) {
        all_overall_metrics[[model_name]] <- overall_metrics
        message("  âœ“ MÃ©tricas gerais extraÃ­das")
      }
      
      # Extrair mÃ©tricas por classe
      byclass_metrics <- extract_byclass_metrics(result_list[[result_key]], model_name)
      if (!is.null(byclass_metrics)) {
        all_byclass_metrics[[model_name]] <- byclass_metrics
        message("  âœ“ MÃ©tricas por classe extraÃ­das")
        message("    Classes encontradas: ", paste(unique(byclass_metrics$Class), collapse = ", "))
        message("    MÃ©tricas disponÃ­veis: ", paste(setdiff(names(byclass_metrics), c("Model", "Class")), collapse = ", "))
      }
      
      # Extrair matriz de confusÃ£o
      if (include_confusion_matrix) {
        conf_mat <- extract_confusion_matrix(result_list[[result_key]], model_name)
        if (!is.null(conf_mat)) {
          all_conf_matrices[[model_name]] <- conf_mat
          message("  âœ“ Matriz de confusÃ£o extraÃ­da")
        }
      }
      message("")
    } else {
      message("âœ— Modelo ", model_name, " nÃ£o encontrado\n")
    }
  }
  
  # Verificar se hÃ¡ dados
  if (length(available_models) == 0) {
    stop("Nenhum modelo vÃ¡lido encontrado.")
  }
  
  message("Total de modelos disponÃ­veis: ", length(available_models), 
          " (", paste(available_models, collapse = ", "), ")\n")
  
  # ============================================================================
  # PARTE 1: MÃ‰TRICAS GERAIS (OVERALL)
  # ============================================================================
  
  overall_metrics_df <- NULL
  overall_metric_plots <- NULL
  combined_overall_plot <- NULL
  
  if (length(all_overall_metrics) > 0) {
    message("=== PROCESSANDO MÃ‰TRICAS GERAIS ===\n")
    
    overall_metrics_df <- do.call(rbind, all_overall_metrics)
    available_overall_metrics <- unique(overall_metrics_df$Metric)
    overall_metrics_to_plot <- intersect(overall_metrics_to_plot, available_overall_metrics)
    
    if (length(overall_metrics_to_plot) == 0) {
      warning("Nenhuma das mÃ©tricas gerais solicitadas foi encontrada.\n",
              "MÃ©tricas disponÃ­veis: ", paste(available_overall_metrics, collapse = ", "))
    } else {
      message("MÃ©tricas gerais a serem plotadas: ", paste(overall_metrics_to_plot, collapse = ", "), "\n")
      
      overall_metric_plots <- list()
      
      for (metric in overall_metrics_to_plot) {
        plot <- create_metric_plot(overall_metrics_df, metric)
        
        if (!is.null(plot)) {
          plot_path <- file.path(save_dir, paste0("overall_metric_", metric, ".png"))
          ggsave(plot_path, plot, 
                 height = overall_metric_individual_height, 
                 width = overall_metric_individual_width, 
                 dpi = dpi)
          message("  â†’ ", metric, " salvo")
          overall_metric_plots[[metric]] <- plot
        }
      }
      
      # Layout automÃ¡tico para mÃ©tricas gerais
      n_metrics <- length(overall_metric_plots)
      
      if (is.null(overall_metrics_nrow) && is.null(overall_metrics_ncol)) {
        if (n_metrics <= 2) {
          overall_metrics_nrow <- 1
          overall_metrics_ncol <- n_metrics
        } else if (n_metrics <= 4) {
          overall_metrics_nrow <- 2
          overall_metrics_ncol <- 2
        } else {
          overall_metrics_ncol <- 3
          overall_metrics_nrow <- ceiling(n_metrics / overall_metrics_ncol)
        }
      } else if (is.null(overall_metrics_nrow)) {
        overall_metrics_nrow <- ceiling(n_metrics / overall_metrics_ncol)
      } else if (is.null(overall_metrics_ncol)) {
        overall_metrics_ncol <- ceiling(n_metrics / overall_metrics_nrow)
      }
      
      if (is.null(overall_metrics_width)) {
        overall_metrics_width <- overall_metric_individual_width * overall_metrics_ncol
      }
      if (is.null(overall_metrics_height)) {
        overall_metrics_height <- overall_metric_individual_height * overall_metrics_nrow
      }
      
      # Plot combinado de mÃ©tricas gerais
      if (n_metrics == 1) {
        combined_overall_plot <- overall_metric_plots[[1]]
      } else {
        combined_overall_plot <- wrap_plots(overall_metric_plots, 
                                            nrow = overall_metrics_nrow, 
                                            ncol = overall_metrics_ncol)
      }
      
      overall_path <- file.path(save_dir, "combined_overall_metrics.png")
      ggsave(overall_path, combined_overall_plot, 
             height = overall_metrics_height, 
             width = overall_metrics_width, 
             dpi = dpi)
      
      message("\nâœ“ Plot combinado de mÃ©tricas gerais salvo")
      message("  Layout: ", overall_metrics_nrow, "x", overall_metrics_ncol, "\n")
    }
  }
  
  # ============================================================================
  # PARTE 2: MÃ‰TRICAS POR CLASSE
  # ============================================================================
  
  byclass_metrics_df <- NULL
  byclass_metric_plots <- NULL
  combined_byclass_plot <- NULL
  
  if (length(all_byclass_metrics) > 0) {
    message("=== PROCESSANDO MÃ‰TRICAS POR CLASSE ===\n")
    
    byclass_metrics_df <- do.call(rbind, all_byclass_metrics)
    available_byclass_metrics <- setdiff(names(byclass_metrics_df), c("Model", "Class"))
    byclass_metrics_to_plot <- intersect(byclass_metrics_to_plot, available_byclass_metrics)
    
    if (length(byclass_metrics_to_plot) == 0) {
      warning("Nenhuma das mÃ©tricas por classe solicitadas foi encontrada.\n",
              "MÃ©tricas disponÃ­veis: ", paste(available_byclass_metrics, collapse = ", "))
    } else {
      message("MÃ©tricas por classe a serem plotadas: ", paste(byclass_metrics_to_plot, collapse = ", "), "\n")
      
      byclass_metric_plots <- list()
      
      for (metric in byclass_metrics_to_plot) {
        plot <- create_byclass_metric_plot(byclass_metrics_df, metric)
        
        if (!is.null(plot)) {
          plot_path <- file.path(save_dir, paste0("byclass_metric_", metric, ".png"))
          ggsave(plot_path, plot, 
                 height = byclass_metric_individual_height, 
                 width = byclass_metric_individual_width, 
                 dpi = dpi)
          message("  â†’ ", metric, " por classe salvo")
          byclass_metric_plots[[metric]] <- plot
        }
      }
      
      # Layout automÃ¡tico para mÃ©tricas por classe
      n_metrics <- length(byclass_metric_plots)
      
      if (is.null(byclass_metrics_nrow) && is.null(byclass_metrics_ncol)) {
        if (n_metrics <= 2) {
          byclass_metrics_nrow <- 1
          byclass_metrics_ncol <- n_metrics
        } else if (n_metrics <= 4) {
          byclass_metrics_nrow <- 2
          byclass_metrics_ncol <- 2
        } else {
          byclass_metrics_ncol <- 2
          byclass_metrics_nrow <- ceiling(n_metrics / byclass_metrics_ncol)
        }
      } else if (is.null(byclass_metrics_nrow)) {
        byclass_metrics_nrow <- ceiling(n_metrics / byclass_metrics_ncol)
      } else if (is.null(byclass_metrics_ncol)) {
        byclass_metrics_ncol <- ceiling(n_metrics / byclass_metrics_nrow)
      }
      
      if (is.null(byclass_metrics_width)) {
        byclass_metrics_width <- byclass_metric_individual_width * byclass_metrics_ncol
      }
      if (is.null(byclass_metrics_height)) {
        byclass_metrics_height <- byclass_metric_individual_height * byclass_metrics_nrow
      }
      
      # Plot combinado de mÃ©tricas por classe
      if (n_metrics == 1) {
        combined_byclass_plot <- byclass_metric_plots[[1]]
      } else {
        combined_byclass_plot <- wrap_plots(byclass_metric_plots, 
                                            nrow = byclass_metrics_nrow, 
                                            ncol = byclass_metrics_ncol)
      }
      
      byclass_path <- file.path(save_dir, "combined_byclass_metrics.png")
      ggsave(byclass_path, combined_byclass_plot, 
             height = byclass_metrics_height, 
             width = byclass_metrics_width, 
             dpi = dpi)
      
      message("\nâœ“ Plot combinado de mÃ©tricas por classe salvo")
      message("  Layout: ", byclass_metrics_nrow, "x", byclass_metrics_ncol, "\n")
    }
  }
  
  # ============================================================================
  # PARTE 3: MATRIZES DE CONFUSÃƒO
  # ============================================================================
  
  cm_plots <- NULL
  combined_cm_plot <- NULL
  
  if (include_confusion_matrix && length(all_conf_matrices) > 0) {
    message("=== PROCESSANDO MATRIZES DE CONFUSÃƒO ===\n")
    
    cm_plots <- list()
    
    for (model_name in names(all_conf_matrices)) {
      conf_mat <- all_conf_matrices[[model_name]]
      plot <- plot_confusion_matrix(conf_mat, model_name)
      
      # Salvar matriz individual
      cm_path <- file.path(save_dir, 
                          paste0("confusion_matrix_", model_name, ".png"))
      ggsave(cm_path, plot, 
             height = cm_individual_size, 
             width = cm_individual_size, 
             dpi = dpi)
      message("  â†’ Matriz ", model_name, " salva")
      
      cm_plots[[model_name]] <- plot
    }
    
    # Layout automÃ¡tico para matrizes
    n_matrices <- length(cm_plots)
    
    if (is.null(cm_nrow) && is.null(cm_ncol)) {
      if (n_matrices == 1) {
        cm_nrow <- 1
        cm_ncol <- 1
      } else if (n_matrices == 2) {
        cm_nrow <- 1
        cm_ncol <- 2
      } else if (n_matrices == 3) {
        cm_nrow <- 1
        cm_ncol <- 3
      } else {
        cm_ncol <- ceiling(sqrt(n_matrices))
        cm_nrow <- ceiling(n_matrices / cm_ncol)
      }
    } else if (is.null(cm_nrow)) {
      cm_nrow <- ceiling(n_matrices / cm_ncol)
    } else if (is.null(cm_ncol)) {
      cm_ncol <- ceiling(n_matrices / cm_nrow)
    }
    
    if (is.null(cm_width)) {
      cm_width <- cm_individual_size * cm_ncol
    }
    if (is.null(cm_height)) {
      cm_height <- cm_individual_size * cm_nrow
    }
    
    # Plot combinado de matrizes
    if (n_matrices == 1) {
      combined_cm_plot <- cm_plots[[1]]
    } else {
      combined_cm_plot <- wrap_plots(cm_plots, 
                                     nrow = cm_nrow, 
                                     ncol = cm_ncol)
    }
    
    cm_combined_path <- file.path(save_dir, "combined_confusion_matrices.png")
    ggsave(cm_combined_path, combined_cm_plot, 
           height = cm_height, 
           width = cm_width, 
           dpi = dpi)
    
    message("\nâœ“ Plot combinado de matrizes salvo")
    message("  Layout: ", cm_nrow, "x", cm_ncol, "\n")
  }
  
  # ============================================================================
  # SALVAR TABELAS RESUMO
  # ============================================================================
  
  message("=== SALVANDO TABELAS RESUMO ===\n")
  
  # Tabela de mÃ©tricas gerais
  if (!is.null(overall_metrics_df)) {
    overall_summary <- reshape(overall_metrics_df, 
                              idvar = "Metric", 
                              timevar = "Model", 
                              direction = "wide")
    names(overall_summary) <- gsub("Value.", "", names(overall_summary))
    
    overall_table_path <- file.path(save_dir, "overall_metrics_summary.csv")
    write.csv(overall_summary, overall_table_path, row.names = FALSE)
    message("âœ“ Tabela de mÃ©tricas gerais: overall_metrics_summary.csv")
  }
  
  # Tabela de mÃ©tricas por classe
  if (!is.null(byclass_metrics_df)) {
    byclass_table_path <- file.path(save_dir, "byclass_metrics_summary.csv")
    write.csv(byclass_metrics_df, byclass_table_path, row.names = FALSE)
    message("âœ“ Tabela de mÃ©tricas por classe: byclass_metrics_summary.csv")
  }
  
  message("\n", strrep("=", 60))
  message("âœ… PROCESSAMENTO CONCLUÃDO!")
  message("ðŸ“ Todos os arquivos salvos em: ", save_dir)
  message(strrep("=", 60), "\n")
  
  # Retornar resultados
  return(list(
    # Plots combinados
    combined_overall_metrics = combined_overall_plot,
    combined_byclass_metrics = combined_byclass_plot,
    combined_confusion_matrices = combined_cm_plot,
    
    # Plots individuais
    individual_overall_plots = overall_metric_plots,
    individual_byclass_plots = byclass_metric_plots,
    individual_cm_plots = cm_plots,
    
    # Dataframes
    overall_metrics_df = overall_metrics_df,
    byclass_metrics_df = byclass_metrics_df,
    overall_summary = if(exists("overall_summary")) overall_summary else NULL,
    
    # InformaÃ§Ãµes
    available_models = available_models,
    available_overall_metrics = if(!is.null(overall_metrics_df)) unique(overall_metrics_df$Metric) else NULL,
    available_byclass_metrics = if(!is.null(byclass_metrics_df)) setdiff(names(byclass_metrics_df), c("Model", "Class")) else NULL,
    classes_found = if(!is.null(byclass_metrics_df)) unique(byclass_metrics_df$Class) else NULL,
    
    save_directory = save_dir
  ))
}

# ============================================================================
# EXEMPLO DE USO
# ============================================================================

# Executar a funÃ§Ã£o
result <- plot_and_save_metrics(
  result_list = band_result,
  save_dir = "F:/orto/results",
  
  # MÃ©tricas gerais (overall) - as mesmas de antes
  overall_metrics_to_plot = c("Accuracy", "Kappa"),
  
  # NOVO: MÃ©tricas por classe - escolha as que vocÃª quer
  byclass_metrics_to_plot = c("Sensitivity", "Specificity", "Precision", 
                              "Recall", "F1", "Balanced Accuracy"),
  
  include_confusion_matrix = TRUE,
  
  # Layout das mÃ©tricas gerais
  overall_metrics_nrow = 1,
  overall_metrics_ncol = 2,
  
  # Layout das mÃ©tricas por classe
  byclass_metrics_nrow = 3,
  byclass_metrics_ncol = 2,
  byclass_metrics_width = 16,
  byclass_metrics_height = 18,
  
  # Layout das matrizes de confusÃ£o
  cm_nrow = 1,
  cm_ncol = 3,
  cm_width = 18,
  cm_height = 6,
  
  dpi = 600
)

# Ver quais mÃ©tricas estÃ£o disponÃ­veis
print("MÃ©tricas gerais disponÃ­veis:")
print(result$available_overall_metrics)

print("\nMÃ©tricas por classe disponÃ­veis:")
print(result$available_byclass_metrics)

print("\nClasses encontradas:")
print(result$classes_found)
```

# 8Â° - Removing the soil background

```{r}
#1Â°) creating a mask and remove the soil
soilmask = band_result$result_SVMRADIAL$map ==1
ortosolo = mask(bandset_1, soilmask, maskvalue = 0)
plot(ortosolo[[1]])

#2Â°) Saving the classify orto
writeRaster(ortosolo, "~/Canola/sens-remoto/classificacao/008_29_07_removed.tif", overwrite = TRUE)

#3Â° Convert to dataframe
df_solo <- as.data.frame(ortosolo[[1]], xy = TRUE, na.rm = TRUE)

#4Â°) Create the map
plot <- ggplot(df_solo, aes(x = x, y = y, fill = names(df_solo)[3])) +
  geom_raster() +
  scale_fill_viridis_d(name = "Valor") +
  labs(color = "Plants")+
  labs(title = "Remove soil map") +
  theme_bw() + 
  theme(legend.position = "Top")
plot

#5Â°) Save the map
ggsave("~/Canola/sens-remoto/orto recortado/results/04_soil_remove_ortho.png", 
       plot, 
       width = 8, 
       height = 5, 
       dpi = 600)
```

# 9Â° - Call the plots and create the buffer

```{r}
#1Â°)loading the plots
plots <- st_read("~/Canola/shp/croqui_15_05.shp")
print(plots)

#2Â°) Converting the coordinate system
plots <- plots %>%
  st_transform(crs = 32723) #converting to UTM is better for buffer function

#3Â°) Converting the raster
ortosolo <- project(ortosolo, "EPSG: 32723")
ortosolo
#3.1Â°) Check the values number, if high divide to 32768
ortosolo <- ortosolo/32768

#4Â°) Check the coordinate system
print(ortosolo)
print(plots)
plot(plots)

#5Â°) Apply the buffer for the plots
plots <- st_buffer(plots, dist = -0.2)
plot(plots)

#6Â°) plot the results of the classification with the plots
fieldView(ortosolo,
          fieldShape = plots,
          type = 2,
          alpha_grid = 0.2)
```
# 10Â° -  Calculate the vegetation index

```{r}
resultados <- mosaic_index(
  ortosolo, 
  index = c("R","G", "NDVI", "NDRE", "GNDVI", 
            "NGRDI", "RVI", "SAVI", 
            "TSAVI", "TVI", "CVI", 
            "CIG","BAI", "OSAVI", 
            "MSR", "NLI", "GOSAVI",
            "RDVI", "TDVI", "ARI", "MSAVI", "VIG", 
            "MSR", "WDRVI"), 
  r = 2, 
  g = 1, 
  b = NA, 
  re = 3, 
  nir = 4
)

resultados
```

# 11Â° - extract the mean values and save

```{r}
#extract the values using the mean
DataTotal<- fieldInfo_extra(
  mosaic = resultados,
  fieldShape = plots, 
  fun = "mean") #extracting the data
DataTotal

#if you want to save the csv file 
writexl::write_xlsx(DataTotal, "~/Canola/sens-remoto/excel_files/08_29_07.xlsx")
```
# 12Â° Plotting the boxplot for comparison

```{r}
# Function to create box plots
create_boxplot <- function(data, x_col, y_col, fill_col, labs, facet = FALSE, var1, var2, theme, xlab = "", ylab = "") { #title = "" add this part for the title
  p <- ggplot(data, aes(x = {{x_col}}, y = .data[[y_col]], fill = as.factor({{ fill_col }}))) +
    #geom_jitter(color = "darkgray", alpha = 0.2)+
    geom_boxplot() +
    labs(fill = labs, x = xlab, y = ylab) +  # Corrected labs
    scale_fill_viridis_d() + 
    theme +  # Apply the theme directly without using =
    theme(legend.position = "top",
      axis.text.y  = element_text(size = 12),
      axis.text.x = element_text(size = 12, angle = 90),
      axis.title = element_text(size = 14),
      legend.title = element_text(size = 14),
      legend.text = element_text(size = 14),
      strip.text = element_text(size = 14)
      #axis.text.x = element_text(angle = 45)

    )

  # Add facet_grid if facet is specified
  if (facet) {
    p <- p + facet_grid(vars({{ var1 }}), vars({{ var2 }}))
  }

  # Add title if provided
  #if (title != "") {
   # p <- p + ggtitle(title)
  #}

  return(p)
}

#1Â°) Define the dataframe
df_new = DataTotal

#2Â°) Show the column names
col <- colnames(df_new)[c(-1,-2,-3,-27)]

#3Â°) Create a list to store plots
plots <- list()

#4Â°) Create individual boxplots
for (column_name in col) {
  plot <- create_boxplot(
    DataTotal,
    cult,
    column_name,
    trat_sem,
    labs = "Seed treat.",
    xlab = "",
    ylab = column_name,
    facet = F,
    var1 = Year,
    var2 = Field,
    theme = theme_bw()  # Correctly pass theme
) # add this part for the title: title = paste("Boxplot of", column_name, "by Fungicide and Cultivar")
  plots[[column_name]] <- plot
  
  # Save each plot with the column name as the filename
  ggsave(
    filename = paste0('~/Canola/test/VI/', column_name, '.png'), 
    plot = plot, width = 7, height = 4
  )
  
  # Store the plot in the list
  plots[[column_name]] <- plot
}

# The plots are saved individually, and you can view them if needed
plots

# Combine plots using patchwork
combined_plot <- wrap_plots(plots, ncol = 4, nrow = 6)
combined_plot

ggsave(filename = '~/Canola/test/VI/combined.png', combined_plot, width = 12, height = 18)
```