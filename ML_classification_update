---
title: "ML Classification"
author: "Thiago Orlando Costa Barboza"
date: "2025-11-03"
output:
  pdf_document: default
  html_document: default
---


# 1° - Install packages and clone github

```{r}

#1° install the packages:
install.packages(c('terra','mapview','sf','stars','caret','mapedit','devtools',"dplyr",
                   "fields","leafem","leafsync","lwgeom","BiocManager","git2r","exactextractr","rgdal", "xgboost",
                   "nnet", "caret", "e1071","pliman", "Rtools","randomForest", "kernelab"))

#2° install the dependency for FieldImageR:
BiocManager::install("EBImage")

#3° install FIELDimageR and FieldImageR.extra:
devtools::install_github("OpenDroneMap/FIELDimageR")
devtools::install_github("filipematias23/FIELDimageR.Extra")
```

# 2° - Call libraries

```{r}

library(webshot)
library(webshot2)
library(tinytex)
library(rmarkdown)
library(raster)
library(FIELDimageR)
library(FIELDimageR.Extra)
library(terra)
library(mapview)
library(sf)
library(stars)
library(nlme)
library(imager)
library(leafsync)
library(pliman)
library(gdalUtilities)
library(ggplot2)
library(gridExtra)
library(RStoolbox)
library(patchwork)
library(tidyr)
library(caret)
library(e1071)    
library(xgboost)    
library(nnet)
library(dplyr)
library(viridis)
library(randomForest)
library(kernlab)
```

# 3° - Find the location to clip the image

```{r, open the image in webshot}

#open the save orthomosaic again
bandset <- rast("~/Canola/sens-remoto/orto/Nova pasta/001_Orto_Canola_Mavic_15-05-25_Multi.tif")
bandset

#Call the shape and find the locations to clip
shp <- read_sf("~/Canola/shp/area_canola.shp")
shp <- st_transform(shp, crs = 4326)
shp

#Clip the field 
bandset_1 <- mask(crop(bandset, shp), shp)

#this function you can see your raster image
#fieldView(bandset_1, shp)

```

# 4° Creating the sample for classification

```{r}
#create the soil and plant samples
# Digitize soil object by drawing polygons at least 5-6 large polygon uniformly distributed
#generate random 400 points for soil class
orto <- bandset_1
soil<-fieldView(mosaic = orto, editor = TRUE)
soil<-st_as_sf(st_sample(soil, 400))
soil$class<-'soil'

# Digitize plants object by drawing polygons 
#The number of polygon will depends upon the number of training points to be generated
#generate random 400 points for plants class
plants<-fieldView(mosaic = orto, editor = TRUE)
plants<-st_as_sf(st_sample(plants, 400))
plants$class<-'plants'

#You also can add more class like forest, water, etc.

#joining all class in one file
training_sam<-rbind(soil,plants)
```

# 5° - Running ML models

```{r, warning = FALSE}
run_classification_models <- function(
  raster_data,
  training_data,
  models = c("rf", "svmRadial", "xgbTree"),
  response_col = "class",
  tune_length = 3,
  kfold = 5,
  train_partition = 0.7,
  min_dist = 0,
  plot_results = TRUE
) {
  # Garantir nomes únicos
  names(raster_data) <- make.unique(names(raster_data))

  # Converter para Spatial se necessário
  if (!inherits(training_data, "Spatial")) {
    training_data <- as(training_data, "Spatial")
  }

  # Armazenar resultados
  results <- list()

  for (model in models) {
    message(paste("Treinando modelo:", model))
    
    model_result <- superClass(
      raster_data,
      trainData = training_data,
      responseCol = response_col,
      model = model,
      tuneLength = tune_length,
      kfold = kfold,
      trainPartition = train_partition,
      minDist = min_dist
    )
    
    # Nome do objeto no padrão result_MODEL
    result_name <- paste0("result_", toupper(gsub("^(.)", "\\U\\1", model, perl = TRUE)))
    
    if (plot_results) {
      plot(model_result$map, main = paste("Mapa classificado -", model))
      fieldView(raster_data, model_result$map)
      print(model_result$validation$performance)
    }
    
    results[[result_name]] <- model_result
  }

  return(results)
}

#After define the function run this line to use the function

band_result <- run_classification_models(raster_data = bandset_1, 
                                         training_data = training_sam,
                                         models = c("rf", "svmRadial", "xgbTree"),
                                         kfold = 5,
                                         train_partition = 0.7,
                                         plot_results = TRUE)

```
# 6° - Save the map

```{r}
# Helper function to convert raster to dataframe
raster_to_df <- function(raster_obj, value_name = "value") {
  df <- as.data.frame(raster_obj, xy = TRUE, na.rm = FALSE)
  if (ncol(df) == 3) {
    names(df)[3] <- value_name
  }
  return(df)
}

# Helper function to plot the raster dataframe
plot_raster_df <- function(df, value_col, title) {
  ggplot(df, aes(x = x, y = y, fill = as.factor(.data[[value_col]]))) +
    geom_raster() +
    scale_fill_viridis_d() +
    coord_equal() +
    labs(title = title, fill = "Class") +
    theme_bw()
}

# Main function - VERSÃO MELHORADA
plot_and_save_results <- function(result_list, 
                                   save_dir,
                                   combined_nrow = NULL,
                                   combined_ncol = NULL,
                                   combined_width = NULL,
                                   combined_height = NULL,
                                   individual_width = 8,
                                   individual_height = 6,
                                   dpi = 600) {
  
  # Verificar se o diretório existe
  if (!dir.exists(save_dir)) {
    stop("Directory does not exist: ", save_dir, 
         "\nPlease create it or check the path.")
  }
  
  # Mapear nomes dos modelos para seus resultados
  model_mapping <- list(
    RF = "result_RF",
    SVM = "result_SVMRADIAL",
    XGB = "result_XGBTREE"
  )
  
  # Verificar quais modelos estão presentes
  available_models <- c()
  results_named <- list()
  
  for (model_name in names(model_mapping)) {
    result_key <- model_mapping[[model_name]]
    
    # Checar se o modelo existe na lista de resultados
    if (!is.null(result_list[[result_key]])) {
      available_models <- c(available_models, model_name)
      results_named[[model_name]] <- result_list[[result_key]]
      message("✓ Modelo ", model_name, " encontrado")
    } else {
      message("✗ Modelo ", model_name, " não encontrado - será ignorado")
    }
  }
  
  # Verificar se pelo menos um modelo foi encontrado
  if (length(available_models) == 0) {
    stop("Nenhum modelo válido encontrado (RF, SVM, XGB). ",
         "Verifique os nomes dos resultados na lista.")
  }
  
  message("\n", length(available_models), " modelo(s) disponível(is): ", 
          paste(available_models, collapse = ", "))
  
  # Criar plots individuais
  plots <- list()
  plot_dfs <- list()
  
  for (model_name in available_models) {
    result <- results_named[[model_name]]
    df <- raster_to_df(result$map, value_name = model_name)
    plot <- plot_raster_df(df, model_name, paste(model_name, "Classification"))
    
    # Salvar plot individual
    plot_path <- file.path(save_dir, paste0("plot_", model_name, ".png"))
    ggsave(plot_path, plot, 
           height = individual_height, 
           width = individual_width, 
           dpi = dpi)
    message("  → Plot individual salvo: ", basename(plot_path))
    
    plots[[model_name]] <- plot
    plot_dfs[[model_name]] <- df
  }
  
  # Configurar layout automático baseado no número de modelos
  n_models <- length(available_models)
  
  # Definir nrow e ncol automaticamente se não fornecidos
  if (is.null(combined_nrow) && is.null(combined_ncol)) {
    if (n_models == 1) {
      combined_nrow <- 1
      combined_ncol <- 1
    } else if (n_models == 2) {
      combined_nrow <- 1
      combined_ncol <- 2
    } else if (n_models == 3) {
      combined_nrow <- 2
      combined_ncol <- 2
    } else {
      # Para mais de 3 modelos (caso futuro)
      combined_ncol <- ceiling(sqrt(n_models))
      combined_nrow <- ceiling(n_models / combined_ncol)
    }
  } else if (is.null(combined_nrow)) {
    combined_nrow <- ceiling(n_models / combined_ncol)
  } else if (is.null(combined_ncol)) {
    combined_ncol <- ceiling(n_models / combined_nrow)
  }
  
  # Definir dimensões automáticas se não fornecidas
  if (is.null(combined_width)) {
    combined_width <- individual_width * combined_ncol
  }
  if (is.null(combined_height)) {
    combined_height <- individual_height * combined_nrow
  }
  
  # Criar plot combinado usando patchwork
  if (n_models == 1) {
    combined_plot <- plots[[1]]
  } else {
    # Combinar plots dinamicamente
    combined_plot <- wrap_plots(plots, nrow = combined_nrow, ncol = combined_ncol)
  }
  
  # Salvar plot combinado
  combined_path <- file.path(save_dir, "combined_plot.png")
  ggsave(combined_path, combined_plot, 
         height = combined_height, 
         width = combined_width, 
         dpi = dpi)
  
  message("\n✓ Model save in ", basename(combined_path))
  message("  Dimensions: ", combined_width, "x", combined_height, "inch")
  message("  Layout: ", combined_nrow, " line x ", combined_ncol, " col(s)")
  message("\n✓ All plots save in: ", save_dir)
  
  # Retornar informações úteis
  return(list(
    combined_plot = combined_plot,
    individual_plots = plots,
    available_models = available_models,
    save_directory = save_dir
  ))
}

#Running the function
combined_result <- plot_and_save_results(
   result_list = band_result,
   save_dir = "~/Canola/test",
   combined_nrow = 3,
   combined_ncol = 1,
   combined_width = 8,
   combined_height = 18)

```

# 7° - Metrics and Confusion matrix

```{r}
# Helper function to extract and format metrics
extract_metrics <- function(result, model_name) {
  if (is.null(result)) return(NULL)
  
  metrics <- NULL
  
  # Tentar extrair métricas de diferentes estruturas
  if (!is.null(result$metrics)) {
    metrics <- result$metrics
  } else if (!is.null(result$validation$performance)) {
    # Estrutura com validation
    perf <- result$validation$performance
    metrics <- list()
    
    # Extrair métricas comuns
    if (!is.null(perf$overall)) metrics <- c(metrics, as.list(perf$overall))
    if (!is.null(perf$byClass)) metrics <- c(metrics, as.list(perf$byClass))
    if (!is.null(perf$accuracy)) metrics$Accuracy <- perf$accuracy
    if (!is.null(perf$kappa)) metrics$Kappa <- perf$kappa
    
  } else if (!is.null(result$confusion_matrix)) {
    # Calcular métricas da matriz de confusão
    cm <- result$confusion_matrix
    metrics <- list(
      Accuracy = sum(diag(cm)) / sum(cm),
      Kappa = result$kappa
    )
  }
  
  if (is.null(metrics) || length(metrics) == 0) {
    warning("Métricas não encontradas para ", model_name)
    return(NULL)
  }
  
  # Converter para dataframe
  metrics_df <- data.frame(
    Metric = names(metrics),
    Value = as.numeric(metrics),
    Model = model_name,
    stringsAsFactors = FALSE
  )
  
  # Filtrar apenas valores numéricos válidos
  metrics_df <- metrics_df[!is.na(metrics_df$Value), ]
  
  return(metrics_df)
}

# Helper function to extract confusion matrix
extract_confusion_matrix <- function(result, model_name) {
  if (is.null(result)) return(NULL)
  
  conf_mat <- NULL
  
  # Tentar diferentes estruturas
  if (!is.null(result$validation$performance$table)) {
    conf_mat <- result$validation$performance$table
  } else if (!is.null(result$confusion_matrix)) {
    conf_mat <- result$confusion_matrix
  } else if (!is.null(result$confusionMatrix)) {
    conf_mat <- result$confusionMatrix$table
  }
  
  if (is.null(conf_mat)) {
    warning("Matriz de confusão não encontrada para ", model_name)
    return(NULL)
  }
  
  return(conf_mat)
}

# Function to create metric comparison plot
create_metric_plot <- function(metrics_df, metric_name, title = NULL) {
  if (is.null(title)) {
    title <- paste(metric_name, "Comparison")
  }
  
  metric_data <- metrics_df[metrics_df$Metric == metric_name, ]
  
  if (nrow(metric_data) == 0) {
    warning("Métrica ", metric_name, " não encontrada")
    return(NULL)
  }
  
  ggplot(metric_data, aes(x = Model, y = Value, fill = Model)) +
    geom_bar(stat = "identity", width = 0.7, color = "black") +
    geom_text(aes(label = sprintf("%.3f", Value)), 
              vjust = -0.5, size = 4, fontface = "bold") +
    scale_fill_viridis_d() +
    ylim(0, max(metric_data$Value) * 1.15) +
    labs(
      title = title,
      x = "Model",
      y = metric_name
    ) +
    theme_bw() +
    theme(
      legend.position = "none",
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10)
    )
}

# Function to plot confusion matrix
plot_confusion_matrix <- function(conf_mat, model_name = "Model") {
  conf_df <- as.data.frame(as.table(conf_mat))
  colnames(conf_df) <- c("Prediction", "Reference", "Count")
  
  ggplot(conf_df, aes(x = Reference, y = Prediction, fill = Count)) +
    geom_tile(color = "white", size = 1) +
    geom_label(aes(label = Count),
               fill = "white",
               color = "black",
               size = 5,
               fontface = "bold",
               label.size = 0.3,
               label.r = unit(0.15, "lines")) +
    scale_fill_viridis_c(option = "D", direction = -1) +
    labs(
      title = paste("Confusion Matrix -", model_name),
      x = "True Class",
      y = "Predicted Class",
      fill = "Count"
    ) +
    coord_equal() +
    theme_bw(base_size = 14) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.position = "right"
    )
}

# MAIN FUNCTION
plot_and_save_metrics <- function(result_list,
                                   save_dir,
                                   metrics_to_plot = c("Accuracy", "Kappa"),
                                   include_confusion_matrix = TRUE,
                                   # Parâmetros para gráficos de métricas
                                   metrics_nrow = NULL,
                                   metrics_ncol = NULL,
                                   metrics_width = NULL,
                                   metrics_height = NULL,
                                   metric_individual_width = 6,
                                   metric_individual_height = 5,
                                   # Parâmetros para matrizes de confusão
                                   cm_nrow = NULL,
                                   cm_ncol = NULL,
                                   cm_width = NULL,
                                   cm_height = NULL,
                                   cm_individual_size = 6,
                                   # Geral
                                   dpi = 600) {
  
  # Verify the directory
  if (!dir.exists(save_dir)) {
    stop("Directory does not exist: ", save_dir, 
         "\nPlease create it or check the path.")
  }
  
  # Mapping names models
  model_mapping <- list(
    RF = "result_RF",
    SVM = "result_SVMRADIAL",
    XGB = "result_XGBTREE"
  )
  
  # check the models
  available_models <- c()
  all_metrics <- list()
  all_conf_matrices <- list()
  
  for (model_name in names(model_mapping)) {
    result_key <- model_mapping[[model_name]]
    
    if (!is.null(result_list[[result_key]])) {
      # extract the metrics
      metrics <- extract_metrics(result_list[[result_key]], model_name)
      
      if (!is.null(metrics)) {
        available_models <- c(available_models, model_name)
        all_metrics[[model_name]] <- metrics
        message("✓ Métricas do modelo ", model_name, " extraídas")
        
        # extract confusion matrix
        if (include_confusion_matrix) {
          conf_mat <- extract_confusion_matrix(result_list[[result_key]], model_name)
          if (!is.null(conf_mat)) {
            all_conf_matrices[[model_name]] <- conf_mat
            message("  ✓ Matriz de confusão do modelo ", model_name, " extraída")
          }
        }
      } else {
        message("✗ not found metric for ", model_name)
      }
    } else {
      message("✗ Model ", model_name, " not found")
    }
  }
  
  # Verify if there are data
  if (length(available_models) == 0) {
    stop("Any model found")
  }
  
  message("\n", length(available_models), " available models: ", 
          paste(available_models, collapse = ", "))
  
  # ============================================================================
  # STEP 1: GRAPHS FOR METRICS
  # ============================================================================
  
  metrics_df <- do.call(rbind, all_metrics)
  available_metrics <- unique(metrics_df$Metric)
  metrics_to_plot <- intersect(metrics_to_plot, available_metrics)
  
  if (length(metrics_to_plot) == 0) {
    warning("Any metric found. ",
            "Available metrics: ", paste(available_metrics, collapse = ", "))
    metric_plots <- NULL
    combined_metrics_plot <- NULL
  } else {
    message("\nMetrics to plot: ", paste(metrics_to_plot, collapse = ", "))
    
    metric_plots <- list()
    
    for (metric in metrics_to_plot) {
      plot <- create_metric_plot(metrics_df, metric)
      
      if (!is.null(plot)) {
        plot_path <- file.path(save_dir, paste0("metric_", metric, ".png"))
        ggsave(plot_path, plot, 
               height = metric_individual_height, 
               width = metric_individual_width, 
               dpi = dpi)
        message("  → ", metric, " salvo")
        metric_plots[[metric]] <- plot
      }
    }
    
    # Automatic layout
    n_metrics <- length(metric_plots)
    
    if (is.null(metrics_nrow) && is.null(metrics_ncol)) {
      if (n_metrics <= 2) {
        metrics_nrow <- 1
        metrics_ncol <- n_metrics
      } else if (n_metrics <= 4) {
        metrics_nrow <- 2
        metrics_ncol <- 2
      } else if (n_metrics <= 6) {
        metrics_nrow <- 2
        metrics_ncol <- 3
      } else {
        metrics_ncol <- 3
        metrics_nrow <- ceiling(n_metrics / metrics_ncol)
      }
    } else if (is.null(metrics_nrow)) {
      metrics_nrow <- ceiling(n_metrics / metrics_ncol)
    } else if (is.null(metrics_ncol)) {
      metrics_ncol <- ceiling(n_metrics / metrics_nrow)
    }
    
    if (is.null(metrics_width)) {
      metrics_width <- metric_individual_width * metrics_ncol
    }
    if (is.null(metrics_height)) {
      metrics_height <- metric_individual_height * metrics_nrow
    }
    
    # Combine the metrics
    if (n_metrics == 1) {
      combined_metrics_plot <- metric_plots[[1]]
    } else {
      combined_metrics_plot <- wrap_plots(metric_plots, 
                                          nrow = metrics_nrow, 
                                          ncol = metrics_ncol)
    }
    
    metrics_path <- file.path(save_dir, "combined_metrics.png")
    ggsave(metrics_path, combined_metrics_plot, 
           height = metrics_height, 
           width = metrics_width, 
           dpi = dpi)
    
    message("\n✓ Plot combined and metrics save")
    message("  Layout: ", metrics_nrow, "x", metrics_ncol)
  }
  
  # ============================================================================
  # STEP 2: CONFUSION MATRIX
  # ============================================================================
  
  cm_plots <- NULL
  combined_cm_plot <- NULL
  
  if (include_confusion_matrix && length(all_conf_matrices) > 0) {
    message("\n--- PROCESSING CONFUSION MATRIX ---")
    
    cm_plots <- list()
    
    for (model_name in names(all_conf_matrices)) {
      conf_mat <- all_conf_matrices[[model_name]]
      plot <- plot_confusion_matrix(conf_mat, model_name)
      
      # Save each confusion matrix
      cm_path <- file.path(save_dir, 
                          paste0("confusion_matrix_", model_name, ".png"))
      ggsave(cm_path, plot, 
             height = cm_individual_size, 
             width = cm_individual_size, 
             dpi = dpi)
      message("  → Matrix ", model_name, " saved")
      
      cm_plots[[model_name]] <- plot
    }
    
    # Automatic layout for CM
    n_matrices <- length(cm_plots)
    
    if (is.null(cm_nrow) && is.null(cm_ncol)) {
      if (n_matrices == 1) {
        cm_nrow <- 1
        cm_ncol <- 1
      } else if (n_matrices == 2) {
        cm_nrow <- 1
        cm_ncol <- 2
      } else if (n_matrices == 3) {
        cm_nrow <- 2
        cm_ncol <- 2
      } else {
        cm_ncol <- ceiling(sqrt(n_matrices))
        cm_nrow <- ceiling(n_matrices / cm_ncol)
      }
    } else if (is.null(cm_nrow)) {
      cm_nrow <- ceiling(n_matrices / cm_ncol)
    } else if (is.null(cm_ncol)) {
      cm_ncol <- ceiling(n_matrices / cm_nrow)
    }
    
    if (is.null(cm_width)) {
      cm_width <- cm_individual_size * cm_ncol
    }
    if (is.null(cm_height)) {
      cm_height <- cm_individual_size * cm_nrow
    }
    
    # Plot combinado de matrizes
    if (n_matrices == 1) {
      combined_cm_plot <- cm_plots[[1]]
    } else {
      combined_cm_plot <- wrap_plots(cm_plots, 
                                     nrow = cm_nrow, 
                                     ncol = cm_ncol)
    }
    
    cm_combined_path <- file.path(save_dir, "combined_confusion_matrices.png")
    ggsave(cm_combined_path, combined_cm_plot, 
           height = cm_height, 
           width = cm_width, 
           dpi = dpi)
    
    message("\n✓ Plot combinado de matrizes salvo")
    message("  Layout: ", cm_nrow, "x", cm_ncol)
  }
  
  # ============================================================================
  # SAVE AN EXCEL FILE
  # ============================================================================
  
  if (!is.null(metrics_df)) {
    summary_table <- reshape(metrics_df, 
                             idvar = "Metric", 
                             timevar = "Model", 
                             direction = "wide")
    names(summary_table) <- gsub("Value.", "", names(summary_table))
    
    table_path <- file.path(save_dir, "metrics_summary.csv")
    write.xlsx(summary_table, table_path, row.names = FALSE)
    message("\n✓ Table save: metrics_summary.xlsx")
  }
  
  message("\n✅ Every file save in: ", save_dir)
  
  # Return the results
  return(list(
    combined_metrics_plot = combined_metrics_plot,
    combined_confusion_matrices = combined_cm_plot,
    individual_metric_plots = metric_plots,
    individual_cm_plots = cm_plots,
    metrics_dataframe = metrics_df,
    summary_table = if(exists("summary_table")) summary_table else NULL,
    available_models = available_models,
    available_metrics = available_metrics,
    save_directory = save_dir
  ))
}

#Running the funtion and evaluate

result <- plot_and_save_metrics(
  result_list = band_result,
  save_dir = "~/Canola/test",
  metrics_to_plot = c("Accuracy", "Kappa", "F1", "Precision", "Sensitivity", "Specificity"),
  include_confusion_matrix = TRUE,
  # Layout das métricas: 2x2
  metrics_nrow = 3,
  metrics_ncol = 2,
  metrics_width = 12,
  metrics_height = 12,
  # Layout das matrizes: 1x3 (horizontal)
  cm_nrow = 1,
  cm_ncol = 3,
  cm_width = 18,
  cm_height = 6)
```

# 8° - Removing the soil background

```{r}
#1°) creating a mask and remove the soil
soilmask = band_result$result_RF$map ==1
ortosolo = mask(bandset_1, soilmask, maskvalue = 0)
plot(ortosolo[[1]])

#2°) Saving the classify orto
writeRaster(ortosolo, "~/Canola/test/15_05_removed.tif", overwrite = TRUE)

#3° Convert to dataframe
df_solo <- as.data.frame(ortosolo[[1]], xy = TRUE, na.rm = TRUE)

#4°) Create the map
plot <- ggplot(df_solo, aes(x = x, y = y, fill = names(df_solo)[3])) +
  geom_raster() +
  scale_fill_viridis_d(name = "Valor") +
  labs(color = "Plants")+
  labs(title = "Remove soil map") +
  theme_bw() + 
  theme(legend.position = "Top")
plot

#5°) Save the map
ggsave("~/Canola/sens-remoto/orto recortado/results/04_soil_remove_ortho.png", 
       plot, 
       width = 8, 
       height = 5, 
       dpi = 600)
```

# 9° - Call the plots and create the buffer

```{r}
#1°)loading the plots
plots <- st_read("~/Canola/shp/croqui_15_05.shp")
print(plots)

#2°) Converting the coordinate system
plots <- plots %>%
  st_transform(crs = 32723) #converting to UTM is better for buffer function

#3°) Converting the raster
ortosolo <- project(ortosolo, "EPSG: 32723")

#3.1°) Check the values number, if high divide to 32768
ortosolo <- ortosolo/32768

#4°) Check the coordinate system
print(ortosolo)
print(plots)
plot(plots)

#5°) Apply the buffer for the plots
plots <- st_buffer(plots, dist = -0.2)
plot(plots)

#6°) plot the results of the classification with the plots
fieldView(ortosolo,
          fieldShape = plots,
          type = 2,
          alpha_grid = 0.2)
```
# 10° -  Calculate the vegetation index

```{r}
resultados <- mosaic_index(
  ortosolo, 
  index = c("R","G", "NDVI", "NDRE", "GNDVI", 
            "NGRDI", "RVI", "SAVI", 
            "TSAVI", "TVI", "CVI", 
            "CIG","BAI", "OSAVI", 
            "MSR", "NLI", "GOSAVI",
            "RDVI", "TDVI", "ARI", "MSAVI", "VIG", 
            "MSR", "WDRVI"), 
  r = 2, 
  g = 1, 
  b = NA, 
  re = 3, 
  nir = 4
)

resultados
```

# 11° - extract the mean values and save

```{r}
#extract the values using the mean
DataTotal<- fieldInfo_extra(
  mosaic = resultados,
  fieldShape = plots, 
  fun = "mean") #extracting the data

DataTotal

#if you want to save the csv file 
writexl::write_xlsx(DataTotal, "~/Canola/test/01_15_05.xlsx")
```
# 12° Plotting the boxplot for comparison

```{r}
# Function to create box plots
create_boxplot <- function(data, x_col, y_col, fill_col, labs, facet = FALSE, var1, var2, theme, xlab = "", ylab = "") { #title = "" add this part for the title
  p <- ggplot(data, aes(x = {{x_col}}, y = .data[[y_col]], fill = as.factor({{ fill_col }}))) +
    #geom_jitter(color = "darkgray", alpha = 0.2)+
    geom_boxplot() +
    labs(fill = labs, x = xlab, y = ylab) +  # Corrected labs
    scale_fill_viridis_d() + 
    theme +  # Apply the theme directly without using =
    theme(legend.position = "top",
      axis.text.y  = element_text(size = 12),
      axis.text.x = element_text(size = 12, angle = 90),
      axis.title = element_text(size = 14),
      legend.title = element_text(size = 14),
      legend.text = element_text(size = 14),
      strip.text = element_text(size = 14)
      #axis.text.x = element_text(angle = 45)

    )

  # Add facet_grid if facet is specified
  if (facet) {
    p <- p + facet_grid(vars({{ var1 }}), vars({{ var2 }}))
  }

  # Add title if provided
  #if (title != "") {
   # p <- p + ggtitle(title)
  #}

  return(p)
}
#1°) Define the dataframe
df_new = DataTotal

#2°) Show the column names
col <- colnames(df_new)[c(-1,-2,-3,-27)]

#3°) Create a list to store plots
plots <- list()

#4°) Create individual boxplots
for (column_name in col) {
  plot <- create_boxplot(
    DataTotal,
    cult,
    column_name,
    trat_sem,
    labs = "Seed treat.",
    xlab = "",
    ylab = column_name,
    facet = F,
    var1 = Year,
    var2 = Field,
    theme = theme_bw()  # Correctly pass theme
) # add this part for the title: title = paste("Boxplot of", column_name, "by Fungicide and Cultivar")
  plots[[column_name]] <- plot
  
  # Save each plot with the column name as the filename
  ggsave(
    filename = paste0('~/Canola/test/VI/', column_name, '.png'), 
    plot = plot, width = 7, height = 4
  )
  
  # Store the plot in the list
  plots[[column_name]] <- plot
}

# The plots are saved individually, and you can view them if needed
plots

# Combine plots using patchwork
combined_plot <- wrap_plots(plots, ncol = 4, nrow = 6)
combined_plot

ggsave(filename = '~/Canola/test/VI/combined.png', combined_plot, width = 12, height = 18)
```

